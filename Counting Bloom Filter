## COUNTING BLOOM FILTERS ##

PART I

# importing libraries to employ in the code
import string
import random
import mmh3
import math
import numpy as np
import seaborn as sns
from matplotlib import pyplot as plt

random.seed(7) # [Optional]:as a point of reference


class cb_filter(object): # creating the class of counting bloom filter
    def __init__(self, size):
        self.size = size 
        self.data = [0 for _ in range(size)] # filling storage with 0s
            
    def insert(self, elem): 
        # incremneting the indices by 1 for the hashed entries
        self.data[self.h1(elem)%self.size] +=1 
        self.data[self.h2(elem)%self.size] +=1
        self.data[self.h3(elem)%self.size] +=1
    
    def search(self, elem): 
        # return True if all are non 0s and false if at least one has a 0
        # trace of an entry using the hash functions
        bit1 = self.data[self.h1(elem)%self.size] 
        bit2 = self.data[self.h2(elem)%self.size]
        bit3 = self.data[self.h3(elem)%self.size]
        # check if any of the 3 slots has a 0
        return  bit1 != 0 and bit2 != 0 and bit3 != 0  
    
    def remove(self, elem): 
        # this function has drawbacks, we discuss this in details in Part 5
        if not cb_filter.search(self, elem): 
            # check whether the element is a true negative
            return print('The word does not exist') 
            # the storage doesn't contain the entry
        else: # the entry might be there, or it can be a false positive
            # deleting 1 from each index of the entry
            self.data[self.h1(elem)%self.size] -=1 
            self.data[self.h2(elem)%self.size] -=1
            self.data[self.h3(elem)%self.size] -=1
    
    def h1(self, elem): # hashing using the mmh3 library
        h_1, h_2 = mmh3.hash64(elem)
        return h_1 * h_2 # returns the product of hash1 and hash2
    
    def h2(self, elem): # hashing function inspired from pre-class CS110 8.1 
        tot = 0
        for chr in elem:
            tot = tot * 128 + ord(chr) 
        return tot
    
    def h3(self, elem): # hashing using the mmh3 library
        h_1, h_2 = mmh3.hash64(elem)
        return h_1 + h_2 # adding the results of both hashing functions


    
n = 1000 # initializing the number of entries
m = 10000 # storage capacity
cbf = cb_filter(m) # assigning the counting bloom filter as cbf

def rand_word(): # generate a random lower case string of size 5 to 10
    return ''.join(random.choice(string.ascii_lowercase) for i in range(random.randint(5,10)))

storage, new_entries = [], [] # the storage and new entries (for testing) 

for _ in range(n): 
    storage.append(rand_word()) # store n strings as initial database
    new_entries.append(rand_word()) # store n strings for testing 

for i in storage: 
    cbf.insert(i) # create a footprint of the words in storage in our cbf

false_pos, true_neg = 0, 0 # initialze the occurances of true - and false +

for i in new_entries: 
    if cbf.search(i) and i not in storage: 
        # search test: True, exist in storage: False
        false_pos += 1 # increment false positive count
    else: # search test: False 
        true_neg += 1 # increment true negative count

# compute the rate of false positive
fp_rate = false_pos/(true_neg + false_pos) 


print(fp_rate)
print(cbf.size)
# the range of the incrementation in the cbf
print(min(cbf.data), max(cbf.data)) 
# count the frequency of each index call
print(np.unique(cbf.data, return_counts=True)) 

# Plotting the histogram of storage
sns.set_style("darkgrid")
plt.figure(figsize=(10, 8))
plt.xlim([min(cbf.data), max(cbf.data)+1])
plt.hist(cbf.data, bins = max(cbf.data), alpha=0.5)
plt.xticks(range(min(cbf.data), max(cbf.data)+1))
plt.title('Uniformity of the hash functions')
plt.xlabel('Index value')
plt.ylabel('count')
plt.show()

PART II

# a. memory size as a function of the false positive rate

rec_rate = []
storage = []
initial = 1000 # fixed initial storage in the bloom filter

for i in range(10, 10000, 10):
    false_pos, true_neg = 0, 0
    storage.append(i) # appending different storage capacities
    cbf = cb_filter(i) # create a footprint of the entries in our cbf
    
    old, new = [], [] # generate random 'initial' for storage and testing
    for j in range(initial):
        old.append(rand_word())
        new.append(rand_word())

    for j in old:
        cbf.insert(j) # create a trace of the words in storage in our cbf
    
    for word in new:
        if cbf.search(word) and word not in old:
            false_pos += 1
        else:
            true_neg += 1
    
    # append the rate correspond to capacity
    rec_rate.append(false_pos/(true_neg + false_pos)) 
    
plt.figure(figsize=(10, 8))
plt.scatter(rec_rate, storage, alpha=0.8, s=10, color='red') 
plt.title('Memory size vs. False Positive Rate')
plt.xlabel("False + rate")
plt.ylabel("Storage")
plt.show()

PART III

# b. memory size as a function of the number of items stored

fix_rate = 0.05 # set a fixed false positive rate
storage, initial = [], [] 

for i in range(10, 1000, 10):
    initial.append(i) # set the number of initial input data
    store = i         # set the capacity of the bloom filter
    fp_rate = 1       # set the max false positive rate
    
    while fp_rate > fix_rate:
        store = int(store * 1.1) # increase the storage capacity by 10%
        cbf = cb_filter(store) # create a footprint of the entries in our cbf
   
        old, new = [], []
        for _ in range(i): # generate random entries for storage and testing
            old.append(rand_word())
            new.append(rand_word())     

        for word in old: # create a trace of the words in storage in our cbf
            cbf.insert(word)

        false_pos = 0
        true_neg = 0
        for word in new:
            if cbf.search(word):
                if word not in old:
                    false_pos += 1
            else:
                true_neg += 1
        # compute the false positive rate
        fp_rate = false_pos/(true_neg + false_pos) 
    
    storage.append(store) # append storage capacity

plt.figure(figsize=(10, 8))
plt.plot(initial, storage)
plt.title("The memory size vs. initial input")
plt.xlabel("Number of item stored")
plt.ylabel("Memory size")
plt.show()

PART IV

# c. access time as a function of the false positive rate
import time


fp_rate = []
access = []
initial = 1000 # fixed initial storage in the bloom filter

for i in range(10, 10000, 50):
    false_pos, true_neg = 0, 0
    storage.append(i)  # appending different storage capacities
    cbf = cb_filter(i) # create a footprint of the entries in our cbf
    
    old, new = [], []  # generate random entries for storage and testing
    for j in range(initial):
        old.append(rand_word())
        new.append(rand_word())

    for j in old:
        cbf.insert(j) # create a trace of the words in storage in our cbf
    
    start = time.time()
    for word in new:
        if cbf.search(word) and word not in old:
            false_pos += 1
        else:
            true_neg += 1
        
    end = time.time()
    access_time = (end-start)
    access.append(access_time)
    
    # append the false positive rate
    fp_rate.append(false_pos/(true_neg + false_pos)) 
    
plt.figure(figsize=(10, 8))
plt.scatter(fp_rate, access, alpha=0.8, s=10, color="green", marker="x") 
plt.title('Access time vs. False Positive Rate')
plt.xlabel("False + rate")
plt.ylabel("Access time")
plt.show()

PART V

# d. access time as a function of the number of items stored
import time

fix_rate = 0.05 # set a fixed false positive rate
initial, access = [], [] 

for i in range(10, 10000, 100):
    initial.append(i)   # set the number of initial input data
    store = 100000   # set a fixed storage capacity of the bloom filter
    false_pos, true_neg = 0, 0  # initialize the counts of false+ and true-
    while True:
        cbf = cb_filter(store)
   
        old, new = [], []
        for _ in range(i): # generate random entries for storage and testing
            old.append(rand_word())
            new.append(rand_word())     

        for word in old: # create a trace of the words in storage in our cbf
            cbf.insert(word)
        
        
        start = time.time() # timer for the access function
        for word in new:
            if cbf.search(word) and word not in old:
                false_pos += 1
            else:
                true_neg += 1
        end = time.time() 
        
        access_time = (end-start) # save the duration of the inquiry
        if false_pos/(true_neg + false_pos) <= fix_rate:
            access.append(access_time) # record access time if rate < fixed_rate
            break # break to test a different initial input size
    
plt.figure(figsize=(10, 8)) 
plt.plot(initial, access)
plt.title("The Access time vs. number of initial input")
plt.xlabel("Number of item stored")
plt.ylabel("Access time")
plt.show()

PART VI 

import math
import matplotlib.pyplot as plt


theory_rate = []
practice_rate = []
storage = []  # storage capacity
entries = 100 # fixed initial entries in the database
hash_func = 3 # setting the number of hash functions

# Theoritical expected rate of false positive
for m in range(10, 1000, 5):
    # Compute the theoritical rate for every storage capacity
    # original version
    # theory_rate.append((1 - (1 - (1/m))**(h*entries))**h)
    
    # simplified version
    theory_rate.append((1 - math.exp(-h*entries/m))**h) 
    root(fp, h) = 1 - math.exp(-h*n/m)
    n (-h)/ln(1 - root(fp, h)) = m


# Practical expected rate of false positive
for i in range(10, 1000, 5):
    false_pos, true_neg = 0, 0 
    old, new = [], []
    
    storage.append(i)  # set the storage capacity
    cbf = cb_filter(i) 
    
    for j in range(entries): # generate random words to store and test
        old.append(rand_word())
        new.append(rand_word())

    for j in old:
        cbf.insert(j) # create a trace of the words in storage in our cbf
    
    for word in new: # check the false positive and true negative counts
        if cbf.search(word) and word not in old:
            false_pos += 1
        else:
            true_neg += 1
    
    # Compute the rate for a given storage size
    practice_rate.append(false_pos/(true_neg + false_pos)) 

# plotting the results of the practical and theoritical relation

plt.figure(figsize=(10, 8))
plt.scatter(storage, practice_rate, color = 'red', alpha = 0.8, label='Practical rate')
plt.plot(storage, theory_rate, color = 'green', alpha = 0.8, label='Theoritical rate')
plt.legend(loc=1)
plt.title('The thoeritical and Practical rates')
plt.xlabel("Storage size")
plt.ylabel("FP Rate")
plt.show()
